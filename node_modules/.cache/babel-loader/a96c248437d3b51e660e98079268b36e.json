{"ast":null,"code":"// Set this to true for production\nvar doCache = false; // Name our cache\n\nvar CACHE_NAME = 'my-pwa-cache-v1'; // Delete old caches that are not our current one!\n\nself.addEventListener(\"activate\", event => {\n  const cacheWhitelist = [CACHE_NAME];\n  event.waitUntil(caches.keys().then(keyList => Promise.all(keyList.map(key => {\n    if (!cacheWhitelist.includes(key)) {\n      console.log('Deleting cache: ' + key);\n      return caches.delete(key);\n    }\n  }))));\n}); // The first time the user starts up the PWA, 'install' is triggered.\n\nself.addEventListener('install', function (event) {\n  if (doCache) {\n    event.waitUntil(caches.open(CACHE_NAME).then(function (cache) {\n      // Get the assets manifest so we can see what our js file is named\n      // This is because webpack hashes it\n      fetch(\"asset-manifest.json\").then(response => {\n        response.json();\n      }).then(assets => {\n        // Open a cache and cache our files\n        // We want to cache the page and the main.js generated by webpack\n        // We could also cache any static assets like CSS or images\n        const urlsToCache = [\"/\", assets[\"main.js\"]];\n        cache.addAll(urlsToCache);\n        console.log('cached');\n      });\n    }));\n  }\n}); // When the webpage goes to fetch files, we intercept that request and serve up the matching files\n// if we have them\n\nself.addEventListener('fetch', function (event) {\n  if (doCache) {\n    event.respondWith(caches.match(event.request).then(function (response) {\n      return response || fetch(event.request);\n    }));\n  }\n});","map":{"version":3,"sources":["C:/react/web-reactku/src/serviceWorker.js"],"names":["doCache","CACHE_NAME","self","addEventListener","event","cacheWhitelist","waitUntil","caches","keys","then","keyList","Promise","all","map","key","includes","console","log","delete","open","cache","fetch","response","json","assets","urlsToCache","addAll","respondWith","match","request"],"mappings":"AAAA;AACA,IAAIA,OAAO,GAAG,KAAd,C,CAEA;;AACA,IAAIC,UAAU,GAAG,iBAAjB,C,CAEA;;AACAC,IAAI,CAACC,gBAAL,CAAsB,UAAtB,EAAkCC,KAAK,IAAI;AACzC,QAAMC,cAAc,GAAG,CAACJ,UAAD,CAAvB;AACAG,EAAAA,KAAK,CAACE,SAAN,CACEC,MAAM,CAACC,IAAP,GACGC,IADH,CACQC,OAAO,IACXC,OAAO,CAACC,GAAR,CAAYF,OAAO,CAACG,GAAR,CAAYC,GAAG,IAAI;AAC7B,QAAI,CAACT,cAAc,CAACU,QAAf,CAAwBD,GAAxB,CAAL,EAAmC;AACjCE,MAAAA,OAAO,CAACC,GAAR,CAAY,qBAAqBH,GAAjC;AACA,aAAOP,MAAM,CAACW,MAAP,CAAcJ,GAAd,CAAP;AACD;AACF,GALW,CAAZ,CAFJ,CADF;AAWD,CAbD,E,CAeA;;AACAZ,IAAI,CAACC,gBAAL,CAAsB,SAAtB,EAAiC,UAASC,KAAT,EAAgB;AAC/C,MAAIJ,OAAJ,EAAa;AACXI,IAAAA,KAAK,CAACE,SAAN,CACEC,MAAM,CAACY,IAAP,CAAYlB,UAAZ,EACGQ,IADH,CACQ,UAASW,KAAT,EAAgB;AACpB;AACA;AACAC,MAAAA,KAAK,CAAC,qBAAD,CAAL,CACGZ,IADH,CACQa,QAAQ,IAAI;AAChBA,QAAAA,QAAQ,CAACC,IAAT;AACD,OAHH,EAIGd,IAJH,CAIQe,MAAM,IAAI;AACd;AACA;AACA;AACA,cAAMC,WAAW,GAAG,CAClB,GADkB,EAElBD,MAAM,CAAC,SAAD,CAFY,CAApB;AAIAJ,QAAAA,KAAK,CAACM,MAAN,CAAaD,WAAb;AACAT,QAAAA,OAAO,CAACC,GAAR,CAAY,QAAZ;AACD,OAdH;AAeD,KAnBH,CADF;AAsBD;AACF,CAzBD,E,CA2BA;AACA;;AACAf,IAAI,CAACC,gBAAL,CAAsB,OAAtB,EAA+B,UAASC,KAAT,EAAgB;AAC3C,MAAIJ,OAAJ,EAAa;AACXI,IAAAA,KAAK,CAACuB,WAAN,CACIpB,MAAM,CAACqB,KAAP,CAAaxB,KAAK,CAACyB,OAAnB,EAA4BpB,IAA5B,CAAiC,UAASa,QAAT,EAAmB;AAChD,aAAOA,QAAQ,IAAID,KAAK,CAACjB,KAAK,CAACyB,OAAP,CAAxB;AACH,KAFD,CADJ;AAKD;AACJ,CARD","sourcesContent":["// Set this to true for production\nvar doCache = false;\n\n// Name our cache\nvar CACHE_NAME = 'my-pwa-cache-v1';\n\n// Delete old caches that are not our current one!\nself.addEventListener(\"activate\", event => {\n  const cacheWhitelist = [CACHE_NAME];\n  event.waitUntil(\n    caches.keys()\n      .then(keyList =>\n        Promise.all(keyList.map(key => {\n          if (!cacheWhitelist.includes(key)) {\n            console.log('Deleting cache: ' + key)\n            return caches.delete(key);\n          }\n        }))\n      )\n  );\n});\n\n// The first time the user starts up the PWA, 'install' is triggered.\nself.addEventListener('install', function(event) {\n  if (doCache) {\n    event.waitUntil(\n      caches.open(CACHE_NAME)\n        .then(function(cache) {\n          // Get the assets manifest so we can see what our js file is named\n          // This is because webpack hashes it\n          fetch(\"asset-manifest.json\")\n            .then(response => {\n              response.json()\n            })\n            .then(assets => {\n              // Open a cache and cache our files\n              // We want to cache the page and the main.js generated by webpack\n              // We could also cache any static assets like CSS or images\n              const urlsToCache = [\n                \"/\",\n                assets[\"main.js\"]\n              ]\n              cache.addAll(urlsToCache)\n              console.log('cached');\n            })\n        })\n    );\n  }\n});\n\n// When the webpage goes to fetch files, we intercept that request and serve up the matching files\n// if we have them\nself.addEventListener('fetch', function(event) {\n    if (doCache) {\n      event.respondWith(\n          caches.match(event.request).then(function(response) {\n              return response || fetch(event.request);\n          })\n      );\n    }\n});"]},"metadata":{},"sourceType":"module"}